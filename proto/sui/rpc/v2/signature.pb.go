// Copyright (c) Mysten Labs, Inc.
// SPDX-License-Identifier: Apache-2.0

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.10
// 	protoc        v3.21.4
// source: sui/rpc/v2/signature.proto

package v2

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// A signature from a user.
type UserSignature struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// This signature serialized as as BCS.
	//
	// When provided as input this will support both the form that is length
	// prefixed as well as not length prefixed.
	Bcs *Bcs `protobuf:"bytes,1,opt,name=bcs,proto3,oneof" json:"bcs,omitempty"`
	// The signature scheme of this signature.
	Scheme *SignatureScheme `protobuf:"varint,2,opt,name=scheme,proto3,enum=sui.rpc.v2.SignatureScheme,oneof" json:"scheme,omitempty"`
	// Types that are valid to be assigned to Signature:
	//
	//	*UserSignature_Simple
	//	*UserSignature_Multisig
	//	*UserSignature_Zklogin
	//	*UserSignature_Passkey
	Signature     isUserSignature_Signature `protobuf_oneof:"signature"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UserSignature) Reset() {
	*x = UserSignature{}
	mi := &file_sui_rpc_v2_signature_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UserSignature) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UserSignature) ProtoMessage() {}

func (x *UserSignature) ProtoReflect() protoreflect.Message {
	mi := &file_sui_rpc_v2_signature_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UserSignature.ProtoReflect.Descriptor instead.
func (*UserSignature) Descriptor() ([]byte, []int) {
	return file_sui_rpc_v2_signature_proto_rawDescGZIP(), []int{0}
}

func (x *UserSignature) GetBcs() *Bcs {
	if x != nil {
		return x.Bcs
	}
	return nil
}

func (x *UserSignature) GetScheme() SignatureScheme {
	if x != nil && x.Scheme != nil {
		return *x.Scheme
	}
	return SignatureScheme_ED25519
}

func (x *UserSignature) GetSignature() isUserSignature_Signature {
	if x != nil {
		return x.Signature
	}
	return nil
}

func (x *UserSignature) GetSimple() *SimpleSignature {
	if x != nil {
		if x, ok := x.Signature.(*UserSignature_Simple); ok {
			return x.Simple
		}
	}
	return nil
}

func (x *UserSignature) GetMultisig() *MultisigAggregatedSignature {
	if x != nil {
		if x, ok := x.Signature.(*UserSignature_Multisig); ok {
			return x.Multisig
		}
	}
	return nil
}

func (x *UserSignature) GetZklogin() *ZkLoginAuthenticator {
	if x != nil {
		if x, ok := x.Signature.(*UserSignature_Zklogin); ok {
			return x.Zklogin
		}
	}
	return nil
}

func (x *UserSignature) GetPasskey() *PasskeyAuthenticator {
	if x != nil {
		if x, ok := x.Signature.(*UserSignature_Passkey); ok {
			return x.Passkey
		}
	}
	return nil
}

type isUserSignature_Signature interface {
	isUserSignature_Signature()
}

type UserSignature_Simple struct {
	// Simple signature if scheme is ed25519 | secp256k1 | secp256r1.
	Simple *SimpleSignature `protobuf:"bytes,3,opt,name=simple,proto3,oneof"`
}

type UserSignature_Multisig struct {
	// The multisig aggregated signature if scheme is `MULTISIG`.
	Multisig *MultisigAggregatedSignature `protobuf:"bytes,4,opt,name=multisig,proto3,oneof"`
}

type UserSignature_Zklogin struct {
	// The zklogin authenticator if scheme is `ZKLOGIN`.
	Zklogin *ZkLoginAuthenticator `protobuf:"bytes,5,opt,name=zklogin,proto3,oneof"`
}

type UserSignature_Passkey struct {
	// The passkey authenticator if scheme is `PASSKEY`.
	Passkey *PasskeyAuthenticator `protobuf:"bytes,6,opt,name=passkey,proto3,oneof"`
}

func (*UserSignature_Simple) isUserSignature_Signature() {}

func (*UserSignature_Multisig) isUserSignature_Signature() {}

func (*UserSignature_Zklogin) isUserSignature_Signature() {}

func (*UserSignature_Passkey) isUserSignature_Signature() {}

// Either an ed25519, secp256k1 or secp256r1 signature
type SimpleSignature struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The signature scheme of this signature.
	Scheme *SignatureScheme `protobuf:"varint,1,opt,name=scheme,proto3,enum=sui.rpc.v2.SignatureScheme,oneof" json:"scheme,omitempty"`
	// Signature bytes
	Signature []byte `protobuf:"bytes,2,opt,name=signature,proto3,oneof" json:"signature,omitempty"`
	// Public key bytes
	PublicKey     []byte `protobuf:"bytes,3,opt,name=public_key,json=publicKey,proto3,oneof" json:"public_key,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SimpleSignature) Reset() {
	*x = SimpleSignature{}
	mi := &file_sui_rpc_v2_signature_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SimpleSignature) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SimpleSignature) ProtoMessage() {}

func (x *SimpleSignature) ProtoReflect() protoreflect.Message {
	mi := &file_sui_rpc_v2_signature_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SimpleSignature.ProtoReflect.Descriptor instead.
func (*SimpleSignature) Descriptor() ([]byte, []int) {
	return file_sui_rpc_v2_signature_proto_rawDescGZIP(), []int{1}
}

func (x *SimpleSignature) GetScheme() SignatureScheme {
	if x != nil && x.Scheme != nil {
		return *x.Scheme
	}
	return SignatureScheme_ED25519
}

func (x *SimpleSignature) GetSignature() []byte {
	if x != nil {
		return x.Signature
	}
	return nil
}

func (x *SimpleSignature) GetPublicKey() []byte {
	if x != nil {
		return x.PublicKey
	}
	return nil
}

// Public key equivalent for zklogin authenticators.
type ZkLoginPublicIdentifier struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	Iss   *string                `protobuf:"bytes,1,opt,name=iss,proto3,oneof" json:"iss,omitempty"`
	// base10 encoded Bn254FieldElement
	AddressSeed   *string `protobuf:"bytes,2,opt,name=address_seed,json=addressSeed,proto3,oneof" json:"address_seed,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ZkLoginPublicIdentifier) Reset() {
	*x = ZkLoginPublicIdentifier{}
	mi := &file_sui_rpc_v2_signature_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ZkLoginPublicIdentifier) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ZkLoginPublicIdentifier) ProtoMessage() {}

func (x *ZkLoginPublicIdentifier) ProtoReflect() protoreflect.Message {
	mi := &file_sui_rpc_v2_signature_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ZkLoginPublicIdentifier.ProtoReflect.Descriptor instead.
func (*ZkLoginPublicIdentifier) Descriptor() ([]byte, []int) {
	return file_sui_rpc_v2_signature_proto_rawDescGZIP(), []int{2}
}

func (x *ZkLoginPublicIdentifier) GetIss() string {
	if x != nil && x.Iss != nil {
		return *x.Iss
	}
	return ""
}

func (x *ZkLoginPublicIdentifier) GetAddressSeed() string {
	if x != nil && x.AddressSeed != nil {
		return *x.AddressSeed
	}
	return ""
}

// Set of valid public keys for multisig committee members.
type MultisigMemberPublicKey struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The signature scheme of this public key.
	Scheme *SignatureScheme `protobuf:"varint,1,opt,name=scheme,proto3,enum=sui.rpc.v2.SignatureScheme,oneof" json:"scheme,omitempty"`
	// Public key bytes if scheme is ed25519 | secp256k1 | secp256r1 | passkey.
	PublicKey []byte `protobuf:"bytes,2,opt,name=public_key,json=publicKey,proto3,oneof" json:"public_key,omitempty"`
	// A zklogin public identifier if scheme is zklogin.
	Zklogin       *ZkLoginPublicIdentifier `protobuf:"bytes,3,opt,name=zklogin,proto3,oneof" json:"zklogin,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MultisigMemberPublicKey) Reset() {
	*x = MultisigMemberPublicKey{}
	mi := &file_sui_rpc_v2_signature_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MultisigMemberPublicKey) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MultisigMemberPublicKey) ProtoMessage() {}

func (x *MultisigMemberPublicKey) ProtoReflect() protoreflect.Message {
	mi := &file_sui_rpc_v2_signature_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MultisigMemberPublicKey.ProtoReflect.Descriptor instead.
func (*MultisigMemberPublicKey) Descriptor() ([]byte, []int) {
	return file_sui_rpc_v2_signature_proto_rawDescGZIP(), []int{3}
}

func (x *MultisigMemberPublicKey) GetScheme() SignatureScheme {
	if x != nil && x.Scheme != nil {
		return *x.Scheme
	}
	return SignatureScheme_ED25519
}

func (x *MultisigMemberPublicKey) GetPublicKey() []byte {
	if x != nil {
		return x.PublicKey
	}
	return nil
}

func (x *MultisigMemberPublicKey) GetZklogin() *ZkLoginPublicIdentifier {
	if x != nil {
		return x.Zklogin
	}
	return nil
}

// A member in a multisig committee.
type MultisigMember struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The public key of the committee member.
	PublicKey *MultisigMemberPublicKey `protobuf:"bytes,1,opt,name=public_key,json=publicKey,proto3,oneof" json:"public_key,omitempty"`
	// The weight of this member's signature.
	Weight        *uint32 `protobuf:"varint,2,opt,name=weight,proto3,oneof" json:"weight,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MultisigMember) Reset() {
	*x = MultisigMember{}
	mi := &file_sui_rpc_v2_signature_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MultisigMember) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MultisigMember) ProtoMessage() {}

func (x *MultisigMember) ProtoReflect() protoreflect.Message {
	mi := &file_sui_rpc_v2_signature_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MultisigMember.ProtoReflect.Descriptor instead.
func (*MultisigMember) Descriptor() ([]byte, []int) {
	return file_sui_rpc_v2_signature_proto_rawDescGZIP(), []int{4}
}

func (x *MultisigMember) GetPublicKey() *MultisigMemberPublicKey {
	if x != nil {
		return x.PublicKey
	}
	return nil
}

func (x *MultisigMember) GetWeight() uint32 {
	if x != nil && x.Weight != nil {
		return *x.Weight
	}
	return 0
}

// A multisig committee.
type MultisigCommittee struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// A list of committee members and their corresponding weight.
	Members []*MultisigMember `protobuf:"bytes,1,rep,name=members,proto3" json:"members,omitempty"`
	// The threshold of signatures needed to validate a signature from
	// this committee.
	Threshold     *uint32 `protobuf:"varint,2,opt,name=threshold,proto3,oneof" json:"threshold,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MultisigCommittee) Reset() {
	*x = MultisigCommittee{}
	mi := &file_sui_rpc_v2_signature_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MultisigCommittee) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MultisigCommittee) ProtoMessage() {}

func (x *MultisigCommittee) ProtoReflect() protoreflect.Message {
	mi := &file_sui_rpc_v2_signature_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MultisigCommittee.ProtoReflect.Descriptor instead.
func (*MultisigCommittee) Descriptor() ([]byte, []int) {
	return file_sui_rpc_v2_signature_proto_rawDescGZIP(), []int{5}
}

func (x *MultisigCommittee) GetMembers() []*MultisigMember {
	if x != nil {
		return x.Members
	}
	return nil
}

func (x *MultisigCommittee) GetThreshold() uint32 {
	if x != nil && x.Threshold != nil {
		return *x.Threshold
	}
	return 0
}

// Aggregated signature from members of a multisig committee.
type MultisigAggregatedSignature struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The plain signatures encoded with signature scheme.
	//
	// The signatures must be in the same order as they are listed in the committee.
	Signatures []*MultisigMemberSignature `protobuf:"bytes,1,rep,name=signatures,proto3" json:"signatures,omitempty"`
	// Bitmap indicating which committee members contributed to the
	// signature.
	Bitmap *uint32 `protobuf:"varint,2,opt,name=bitmap,proto3,oneof" json:"bitmap,omitempty"`
	// If present, means this signature's on-chain format uses the old
	// legacy multisig format.
	LegacyBitmap []byte `protobuf:"bytes,3,opt,name=legacy_bitmap,json=legacyBitmap,proto3,oneof" json:"legacy_bitmap,omitempty"`
	// The committee to use to validate this signature.
	Committee     *MultisigCommittee `protobuf:"bytes,4,opt,name=committee,proto3,oneof" json:"committee,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MultisigAggregatedSignature) Reset() {
	*x = MultisigAggregatedSignature{}
	mi := &file_sui_rpc_v2_signature_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MultisigAggregatedSignature) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MultisigAggregatedSignature) ProtoMessage() {}

func (x *MultisigAggregatedSignature) ProtoReflect() protoreflect.Message {
	mi := &file_sui_rpc_v2_signature_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MultisigAggregatedSignature.ProtoReflect.Descriptor instead.
func (*MultisigAggregatedSignature) Descriptor() ([]byte, []int) {
	return file_sui_rpc_v2_signature_proto_rawDescGZIP(), []int{6}
}

func (x *MultisigAggregatedSignature) GetSignatures() []*MultisigMemberSignature {
	if x != nil {
		return x.Signatures
	}
	return nil
}

func (x *MultisigAggregatedSignature) GetBitmap() uint32 {
	if x != nil && x.Bitmap != nil {
		return *x.Bitmap
	}
	return 0
}

func (x *MultisigAggregatedSignature) GetLegacyBitmap() []byte {
	if x != nil {
		return x.LegacyBitmap
	}
	return nil
}

func (x *MultisigAggregatedSignature) GetCommittee() *MultisigCommittee {
	if x != nil {
		return x.Committee
	}
	return nil
}

// A signature from a member of a multisig committee.
type MultisigMemberSignature struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The signature scheme of this signature.
	Scheme *SignatureScheme `protobuf:"varint,1,opt,name=scheme,proto3,enum=sui.rpc.v2.SignatureScheme,oneof" json:"scheme,omitempty"`
	// Signature bytes if scheme is ed25519 | secp256k1 | secp256r1.
	Signature []byte `protobuf:"bytes,2,opt,name=signature,proto3,oneof" json:"signature,omitempty"`
	// The zklogin authenticator if scheme is `ZKLOGIN`.
	Zklogin *ZkLoginAuthenticator `protobuf:"bytes,3,opt,name=zklogin,proto3,oneof" json:"zklogin,omitempty"`
	// The passkey authenticator if scheme is `PASSKEY`.
	Passkey       *PasskeyAuthenticator `protobuf:"bytes,4,opt,name=passkey,proto3,oneof" json:"passkey,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MultisigMemberSignature) Reset() {
	*x = MultisigMemberSignature{}
	mi := &file_sui_rpc_v2_signature_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MultisigMemberSignature) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MultisigMemberSignature) ProtoMessage() {}

func (x *MultisigMemberSignature) ProtoReflect() protoreflect.Message {
	mi := &file_sui_rpc_v2_signature_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MultisigMemberSignature.ProtoReflect.Descriptor instead.
func (*MultisigMemberSignature) Descriptor() ([]byte, []int) {
	return file_sui_rpc_v2_signature_proto_rawDescGZIP(), []int{7}
}

func (x *MultisigMemberSignature) GetScheme() SignatureScheme {
	if x != nil && x.Scheme != nil {
		return *x.Scheme
	}
	return SignatureScheme_ED25519
}

func (x *MultisigMemberSignature) GetSignature() []byte {
	if x != nil {
		return x.Signature
	}
	return nil
}

func (x *MultisigMemberSignature) GetZklogin() *ZkLoginAuthenticator {
	if x != nil {
		return x.Zklogin
	}
	return nil
}

func (x *MultisigMemberSignature) GetPasskey() *PasskeyAuthenticator {
	if x != nil {
		return x.Passkey
	}
	return nil
}

// A zklogin authenticator.
type ZkLoginAuthenticator struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Zklogin proof and inputs required to perform proof verification.
	Inputs *ZkLoginInputs `protobuf:"bytes,1,opt,name=inputs,proto3,oneof" json:"inputs,omitempty"`
	// Maximum epoch for which the proof is valid.
	MaxEpoch *uint64 `protobuf:"varint,2,opt,name=max_epoch,json=maxEpoch,proto3,oneof" json:"max_epoch,omitempty"`
	// User signature with the public key attested to by the provided proof.
	Signature *SimpleSignature `protobuf:"bytes,3,opt,name=signature,proto3,oneof" json:"signature,omitempty"`
	// The public identifier (similar to a public key) for this zklogin authenticator
	PublicIdentifier *ZkLoginPublicIdentifier `protobuf:"bytes,4,opt,name=public_identifier,json=publicIdentifier,proto3,oneof" json:"public_identifier,omitempty"`
	// The id of the JWK used to authorize this zklogin authenticator
	JwkId         *JwkId `protobuf:"bytes,5,opt,name=jwk_id,json=jwkId,proto3,oneof" json:"jwk_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ZkLoginAuthenticator) Reset() {
	*x = ZkLoginAuthenticator{}
	mi := &file_sui_rpc_v2_signature_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ZkLoginAuthenticator) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ZkLoginAuthenticator) ProtoMessage() {}

func (x *ZkLoginAuthenticator) ProtoReflect() protoreflect.Message {
	mi := &file_sui_rpc_v2_signature_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ZkLoginAuthenticator.ProtoReflect.Descriptor instead.
func (*ZkLoginAuthenticator) Descriptor() ([]byte, []int) {
	return file_sui_rpc_v2_signature_proto_rawDescGZIP(), []int{8}
}

func (x *ZkLoginAuthenticator) GetInputs() *ZkLoginInputs {
	if x != nil {
		return x.Inputs
	}
	return nil
}

func (x *ZkLoginAuthenticator) GetMaxEpoch() uint64 {
	if x != nil && x.MaxEpoch != nil {
		return *x.MaxEpoch
	}
	return 0
}

func (x *ZkLoginAuthenticator) GetSignature() *SimpleSignature {
	if x != nil {
		return x.Signature
	}
	return nil
}

func (x *ZkLoginAuthenticator) GetPublicIdentifier() *ZkLoginPublicIdentifier {
	if x != nil {
		return x.PublicIdentifier
	}
	return nil
}

func (x *ZkLoginAuthenticator) GetJwkId() *JwkId {
	if x != nil {
		return x.JwkId
	}
	return nil
}

// A zklogin groth16 proof and the required inputs to perform proof verification.
type ZkLoginInputs struct {
	state            protoimpl.MessageState `protogen:"open.v1"`
	ProofPoints      *ZkLoginProof          `protobuf:"bytes,1,opt,name=proof_points,json=proofPoints,proto3,oneof" json:"proof_points,omitempty"`
	IssBase64Details *ZkLoginClaim          `protobuf:"bytes,2,opt,name=iss_base64_details,json=issBase64Details,proto3,oneof" json:"iss_base64_details,omitempty"`
	HeaderBase64     *string                `protobuf:"bytes,3,opt,name=header_base64,json=headerBase64,proto3,oneof" json:"header_base64,omitempty"`
	// base10 encoded Bn254FieldElement
	AddressSeed   *string `protobuf:"bytes,4,opt,name=address_seed,json=addressSeed,proto3,oneof" json:"address_seed,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ZkLoginInputs) Reset() {
	*x = ZkLoginInputs{}
	mi := &file_sui_rpc_v2_signature_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ZkLoginInputs) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ZkLoginInputs) ProtoMessage() {}

func (x *ZkLoginInputs) ProtoReflect() protoreflect.Message {
	mi := &file_sui_rpc_v2_signature_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ZkLoginInputs.ProtoReflect.Descriptor instead.
func (*ZkLoginInputs) Descriptor() ([]byte, []int) {
	return file_sui_rpc_v2_signature_proto_rawDescGZIP(), []int{9}
}

func (x *ZkLoginInputs) GetProofPoints() *ZkLoginProof {
	if x != nil {
		return x.ProofPoints
	}
	return nil
}

func (x *ZkLoginInputs) GetIssBase64Details() *ZkLoginClaim {
	if x != nil {
		return x.IssBase64Details
	}
	return nil
}

func (x *ZkLoginInputs) GetHeaderBase64() string {
	if x != nil && x.HeaderBase64 != nil {
		return *x.HeaderBase64
	}
	return ""
}

func (x *ZkLoginInputs) GetAddressSeed() string {
	if x != nil && x.AddressSeed != nil {
		return *x.AddressSeed
	}
	return ""
}

// A zklogin groth16 proof.
type ZkLoginProof struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	A             *CircomG1              `protobuf:"bytes,1,opt,name=a,proto3,oneof" json:"a,omitempty"`
	B             *CircomG2              `protobuf:"bytes,2,opt,name=b,proto3,oneof" json:"b,omitempty"`
	C             *CircomG1              `protobuf:"bytes,3,opt,name=c,proto3,oneof" json:"c,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ZkLoginProof) Reset() {
	*x = ZkLoginProof{}
	mi := &file_sui_rpc_v2_signature_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ZkLoginProof) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ZkLoginProof) ProtoMessage() {}

func (x *ZkLoginProof) ProtoReflect() protoreflect.Message {
	mi := &file_sui_rpc_v2_signature_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ZkLoginProof.ProtoReflect.Descriptor instead.
func (*ZkLoginProof) Descriptor() ([]byte, []int) {
	return file_sui_rpc_v2_signature_proto_rawDescGZIP(), []int{10}
}

func (x *ZkLoginProof) GetA() *CircomG1 {
	if x != nil {
		return x.A
	}
	return nil
}

func (x *ZkLoginProof) GetB() *CircomG2 {
	if x != nil {
		return x.B
	}
	return nil
}

func (x *ZkLoginProof) GetC() *CircomG1 {
	if x != nil {
		return x.C
	}
	return nil
}

// A claim of the iss in a zklogin proof.
type ZkLoginClaim struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Value         *string                `protobuf:"bytes,1,opt,name=value,proto3,oneof" json:"value,omitempty"`
	IndexMod_4    *uint32                `protobuf:"varint,2,opt,name=index_mod_4,json=indexMod4,proto3,oneof" json:"index_mod_4,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ZkLoginClaim) Reset() {
	*x = ZkLoginClaim{}
	mi := &file_sui_rpc_v2_signature_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ZkLoginClaim) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ZkLoginClaim) ProtoMessage() {}

func (x *ZkLoginClaim) ProtoReflect() protoreflect.Message {
	mi := &file_sui_rpc_v2_signature_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ZkLoginClaim.ProtoReflect.Descriptor instead.
func (*ZkLoginClaim) Descriptor() ([]byte, []int) {
	return file_sui_rpc_v2_signature_proto_rawDescGZIP(), []int{11}
}

func (x *ZkLoginClaim) GetValue() string {
	if x != nil && x.Value != nil {
		return *x.Value
	}
	return ""
}

func (x *ZkLoginClaim) GetIndexMod_4() uint32 {
	if x != nil && x.IndexMod_4 != nil {
		return *x.IndexMod_4
	}
	return 0
}

// A G1 point.
type CircomG1 struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// base10 encoded Bn254FieldElement
	E0 *string `protobuf:"bytes,1,opt,name=e0,proto3,oneof" json:"e0,omitempty"`
	// base10 encoded Bn254FieldElement
	E1 *string `protobuf:"bytes,2,opt,name=e1,proto3,oneof" json:"e1,omitempty"`
	// base10 encoded Bn254FieldElement
	E2            *string `protobuf:"bytes,3,opt,name=e2,proto3,oneof" json:"e2,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CircomG1) Reset() {
	*x = CircomG1{}
	mi := &file_sui_rpc_v2_signature_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CircomG1) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CircomG1) ProtoMessage() {}

func (x *CircomG1) ProtoReflect() protoreflect.Message {
	mi := &file_sui_rpc_v2_signature_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CircomG1.ProtoReflect.Descriptor instead.
func (*CircomG1) Descriptor() ([]byte, []int) {
	return file_sui_rpc_v2_signature_proto_rawDescGZIP(), []int{12}
}

func (x *CircomG1) GetE0() string {
	if x != nil && x.E0 != nil {
		return *x.E0
	}
	return ""
}

func (x *CircomG1) GetE1() string {
	if x != nil && x.E1 != nil {
		return *x.E1
	}
	return ""
}

func (x *CircomG1) GetE2() string {
	if x != nil && x.E2 != nil {
		return *x.E2
	}
	return ""
}

// A G2 point.
type CircomG2 struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// base10 encoded Bn254FieldElement
	E00 *string `protobuf:"bytes,1,opt,name=e00,proto3,oneof" json:"e00,omitempty"`
	// base10 encoded Bn254FieldElement
	E01 *string `protobuf:"bytes,2,opt,name=e01,proto3,oneof" json:"e01,omitempty"`
	// base10 encoded Bn254FieldElement
	E10 *string `protobuf:"bytes,3,opt,name=e10,proto3,oneof" json:"e10,omitempty"`
	// base10 encoded Bn254FieldElement
	E11 *string `protobuf:"bytes,4,opt,name=e11,proto3,oneof" json:"e11,omitempty"`
	// base10 encoded Bn254FieldElement
	E20 *string `protobuf:"bytes,5,opt,name=e20,proto3,oneof" json:"e20,omitempty"`
	// base10 encoded Bn254FieldElement
	E21           *string `protobuf:"bytes,6,opt,name=e21,proto3,oneof" json:"e21,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CircomG2) Reset() {
	*x = CircomG2{}
	mi := &file_sui_rpc_v2_signature_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CircomG2) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CircomG2) ProtoMessage() {}

func (x *CircomG2) ProtoReflect() protoreflect.Message {
	mi := &file_sui_rpc_v2_signature_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CircomG2.ProtoReflect.Descriptor instead.
func (*CircomG2) Descriptor() ([]byte, []int) {
	return file_sui_rpc_v2_signature_proto_rawDescGZIP(), []int{13}
}

func (x *CircomG2) GetE00() string {
	if x != nil && x.E00 != nil {
		return *x.E00
	}
	return ""
}

func (x *CircomG2) GetE01() string {
	if x != nil && x.E01 != nil {
		return *x.E01
	}
	return ""
}

func (x *CircomG2) GetE10() string {
	if x != nil && x.E10 != nil {
		return *x.E10
	}
	return ""
}

func (x *CircomG2) GetE11() string {
	if x != nil && x.E11 != nil {
		return *x.E11
	}
	return ""
}

func (x *CircomG2) GetE20() string {
	if x != nil && x.E20 != nil {
		return *x.E20
	}
	return ""
}

func (x *CircomG2) GetE21() string {
	if x != nil && x.E21 != nil {
		return *x.E21
	}
	return ""
}

// A passkey authenticator.
//
// See
// [struct.PasskeyAuthenticator](https://mystenlabs.github.io/sui-rust-sdk/sui_sdk_types/struct.PasskeyAuthenticator.html#bcs)
// for more information on the requirements on the shape of the
// `client_data_json` field.
type PasskeyAuthenticator struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Opaque authenticator data for this passkey signature.
	//
	// See [Authenticator Data](https://www.w3.org/TR/webauthn-2/#sctn-authenticator-data) for
	// more information on this field.
	AuthenticatorData []byte `protobuf:"bytes,1,opt,name=authenticator_data,json=authenticatorData,proto3,oneof" json:"authenticator_data,omitempty"`
	// Structured, unparsed, JSON for this passkey signature.
	//
	// See [CollectedClientData](https://www.w3.org/TR/webauthn-2/#dictdef-collectedclientdata)
	// for more information on this field.
	ClientDataJson *string `protobuf:"bytes,2,opt,name=client_data_json,json=clientDataJson,proto3,oneof" json:"client_data_json,omitempty"`
	// A secp256r1 signature.
	Signature     *SimpleSignature `protobuf:"bytes,3,opt,name=signature,proto3,oneof" json:"signature,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PasskeyAuthenticator) Reset() {
	*x = PasskeyAuthenticator{}
	mi := &file_sui_rpc_v2_signature_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PasskeyAuthenticator) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PasskeyAuthenticator) ProtoMessage() {}

func (x *PasskeyAuthenticator) ProtoReflect() protoreflect.Message {
	mi := &file_sui_rpc_v2_signature_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PasskeyAuthenticator.ProtoReflect.Descriptor instead.
func (*PasskeyAuthenticator) Descriptor() ([]byte, []int) {
	return file_sui_rpc_v2_signature_proto_rawDescGZIP(), []int{14}
}

func (x *PasskeyAuthenticator) GetAuthenticatorData() []byte {
	if x != nil {
		return x.AuthenticatorData
	}
	return nil
}

func (x *PasskeyAuthenticator) GetClientDataJson() string {
	if x != nil && x.ClientDataJson != nil {
		return *x.ClientDataJson
	}
	return ""
}

func (x *PasskeyAuthenticator) GetSignature() *SimpleSignature {
	if x != nil {
		return x.Signature
	}
	return nil
}

// The validator set for a particular epoch.
type ValidatorCommittee struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The epoch where this committee governs.
	Epoch *uint64 `protobuf:"varint,1,opt,name=epoch,proto3,oneof" json:"epoch,omitempty"`
	// The committee members.
	Members       []*ValidatorCommitteeMember `protobuf:"bytes,2,rep,name=members,proto3" json:"members,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ValidatorCommittee) Reset() {
	*x = ValidatorCommittee{}
	mi := &file_sui_rpc_v2_signature_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ValidatorCommittee) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ValidatorCommittee) ProtoMessage() {}

func (x *ValidatorCommittee) ProtoReflect() protoreflect.Message {
	mi := &file_sui_rpc_v2_signature_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ValidatorCommittee.ProtoReflect.Descriptor instead.
func (*ValidatorCommittee) Descriptor() ([]byte, []int) {
	return file_sui_rpc_v2_signature_proto_rawDescGZIP(), []int{15}
}

func (x *ValidatorCommittee) GetEpoch() uint64 {
	if x != nil && x.Epoch != nil {
		return *x.Epoch
	}
	return 0
}

func (x *ValidatorCommittee) GetMembers() []*ValidatorCommitteeMember {
	if x != nil {
		return x.Members
	}
	return nil
}

// A member of a validator committee.
type ValidatorCommitteeMember struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The 96-byte Bls12381 public key for this validator.
	PublicKey []byte `protobuf:"bytes,1,opt,name=public_key,json=publicKey,proto3,oneof" json:"public_key,omitempty"`
	// voting weight this validator possesses.
	Weight        *uint64 `protobuf:"varint,2,opt,name=weight,proto3,oneof" json:"weight,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ValidatorCommitteeMember) Reset() {
	*x = ValidatorCommitteeMember{}
	mi := &file_sui_rpc_v2_signature_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ValidatorCommitteeMember) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ValidatorCommitteeMember) ProtoMessage() {}

func (x *ValidatorCommitteeMember) ProtoReflect() protoreflect.Message {
	mi := &file_sui_rpc_v2_signature_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ValidatorCommitteeMember.ProtoReflect.Descriptor instead.
func (*ValidatorCommitteeMember) Descriptor() ([]byte, []int) {
	return file_sui_rpc_v2_signature_proto_rawDescGZIP(), []int{16}
}

func (x *ValidatorCommitteeMember) GetPublicKey() []byte {
	if x != nil {
		return x.PublicKey
	}
	return nil
}

func (x *ValidatorCommitteeMember) GetWeight() uint64 {
	if x != nil && x.Weight != nil {
		return *x.Weight
	}
	return 0
}

// / An aggregated signature from multiple validators.
type ValidatorAggregatedSignature struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The epoch when this signature was produced.
	//
	// This can be used to lookup the `ValidatorCommittee` from this epoch
	// to verify this signature.
	Epoch *uint64 `protobuf:"varint,1,opt,name=epoch,proto3,oneof" json:"epoch,omitempty"`
	// The 48-byte Bls12381 aggregated signature.
	Signature []byte `protobuf:"bytes,2,opt,name=signature,proto3,oneof" json:"signature,omitempty"`
	// Bitmap indicating which members of the committee contributed to
	// this signature.
	Bitmap        []byte `protobuf:"bytes,3,opt,name=bitmap,proto3,oneof" json:"bitmap,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ValidatorAggregatedSignature) Reset() {
	*x = ValidatorAggregatedSignature{}
	mi := &file_sui_rpc_v2_signature_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ValidatorAggregatedSignature) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ValidatorAggregatedSignature) ProtoMessage() {}

func (x *ValidatorAggregatedSignature) ProtoReflect() protoreflect.Message {
	mi := &file_sui_rpc_v2_signature_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ValidatorAggregatedSignature.ProtoReflect.Descriptor instead.
func (*ValidatorAggregatedSignature) Descriptor() ([]byte, []int) {
	return file_sui_rpc_v2_signature_proto_rawDescGZIP(), []int{17}
}

func (x *ValidatorAggregatedSignature) GetEpoch() uint64 {
	if x != nil && x.Epoch != nil {
		return *x.Epoch
	}
	return 0
}

func (x *ValidatorAggregatedSignature) GetSignature() []byte {
	if x != nil {
		return x.Signature
	}
	return nil
}

func (x *ValidatorAggregatedSignature) GetBitmap() []byte {
	if x != nil {
		return x.Bitmap
	}
	return nil
}

var File_sui_rpc_v2_signature_proto protoreflect.FileDescriptor

const file_sui_rpc_v2_signature_proto_rawDesc = "" +
	"\n" +
	"\x1asui/rpc/v2/signature.proto\x12\n" +
	"sui.rpc.v2\x1a\x14sui/rpc/v2/bcs.proto\x1a\x14sui/rpc/v2/jwk.proto\x1a!sui/rpc/v2/signature_scheme.proto\"\x8b\x03\n" +
	"\rUserSignature\x12&\n" +
	"\x03bcs\x18\x01 \x01(\v2\x0f.sui.rpc.v2.BcsH\x01R\x03bcs\x88\x01\x01\x128\n" +
	"\x06scheme\x18\x02 \x01(\x0e2\x1b.sui.rpc.v2.SignatureSchemeH\x02R\x06scheme\x88\x01\x01\x125\n" +
	"\x06simple\x18\x03 \x01(\v2\x1b.sui.rpc.v2.SimpleSignatureH\x00R\x06simple\x12E\n" +
	"\bmultisig\x18\x04 \x01(\v2'.sui.rpc.v2.MultisigAggregatedSignatureH\x00R\bmultisig\x12<\n" +
	"\azklogin\x18\x05 \x01(\v2 .sui.rpc.v2.ZkLoginAuthenticatorH\x00R\azklogin\x12<\n" +
	"\apasskey\x18\x06 \x01(\v2 .sui.rpc.v2.PasskeyAuthenticatorH\x00R\apasskeyB\v\n" +
	"\tsignatureB\x06\n" +
	"\x04_bcsB\t\n" +
	"\a_scheme\"\xba\x01\n" +
	"\x0fSimpleSignature\x128\n" +
	"\x06scheme\x18\x01 \x01(\x0e2\x1b.sui.rpc.v2.SignatureSchemeH\x00R\x06scheme\x88\x01\x01\x12!\n" +
	"\tsignature\x18\x02 \x01(\fH\x01R\tsignature\x88\x01\x01\x12\"\n" +
	"\n" +
	"public_key\x18\x03 \x01(\fH\x02R\tpublicKey\x88\x01\x01B\t\n" +
	"\a_schemeB\f\n" +
	"\n" +
	"_signatureB\r\n" +
	"\v_public_key\"q\n" +
	"\x17ZkLoginPublicIdentifier\x12\x15\n" +
	"\x03iss\x18\x01 \x01(\tH\x00R\x03iss\x88\x01\x01\x12&\n" +
	"\faddress_seed\x18\x02 \x01(\tH\x01R\vaddressSeed\x88\x01\x01B\x06\n" +
	"\x04_issB\x0f\n" +
	"\r_address_seed\"\xe1\x01\n" +
	"\x17MultisigMemberPublicKey\x128\n" +
	"\x06scheme\x18\x01 \x01(\x0e2\x1b.sui.rpc.v2.SignatureSchemeH\x00R\x06scheme\x88\x01\x01\x12\"\n" +
	"\n" +
	"public_key\x18\x02 \x01(\fH\x01R\tpublicKey\x88\x01\x01\x12B\n" +
	"\azklogin\x18\x03 \x01(\v2#.sui.rpc.v2.ZkLoginPublicIdentifierH\x02R\azklogin\x88\x01\x01B\t\n" +
	"\a_schemeB\r\n" +
	"\v_public_keyB\n" +
	"\n" +
	"\b_zklogin\"\x90\x01\n" +
	"\x0eMultisigMember\x12G\n" +
	"\n" +
	"public_key\x18\x01 \x01(\v2#.sui.rpc.v2.MultisigMemberPublicKeyH\x00R\tpublicKey\x88\x01\x01\x12\x1b\n" +
	"\x06weight\x18\x02 \x01(\rH\x01R\x06weight\x88\x01\x01B\r\n" +
	"\v_public_keyB\t\n" +
	"\a_weight\"z\n" +
	"\x11MultisigCommittee\x124\n" +
	"\amembers\x18\x01 \x03(\v2\x1a.sui.rpc.v2.MultisigMemberR\amembers\x12!\n" +
	"\tthreshold\x18\x02 \x01(\rH\x00R\tthreshold\x88\x01\x01B\f\n" +
	"\n" +
	"_threshold\"\x96\x02\n" +
	"\x1bMultisigAggregatedSignature\x12C\n" +
	"\n" +
	"signatures\x18\x01 \x03(\v2#.sui.rpc.v2.MultisigMemberSignatureR\n" +
	"signatures\x12\x1b\n" +
	"\x06bitmap\x18\x02 \x01(\rH\x00R\x06bitmap\x88\x01\x01\x12(\n" +
	"\rlegacy_bitmap\x18\x03 \x01(\fH\x01R\flegacyBitmap\x88\x01\x01\x12@\n" +
	"\tcommittee\x18\x04 \x01(\v2\x1d.sui.rpc.v2.MultisigCommitteeH\x02R\tcommittee\x88\x01\x01B\t\n" +
	"\a_bitmapB\x10\n" +
	"\x0e_legacy_bitmapB\f\n" +
	"\n" +
	"_committee\"\xa9\x02\n" +
	"\x17MultisigMemberSignature\x128\n" +
	"\x06scheme\x18\x01 \x01(\x0e2\x1b.sui.rpc.v2.SignatureSchemeH\x00R\x06scheme\x88\x01\x01\x12!\n" +
	"\tsignature\x18\x02 \x01(\fH\x01R\tsignature\x88\x01\x01\x12?\n" +
	"\azklogin\x18\x03 \x01(\v2 .sui.rpc.v2.ZkLoginAuthenticatorH\x02R\azklogin\x88\x01\x01\x12?\n" +
	"\apasskey\x18\x04 \x01(\v2 .sui.rpc.v2.PasskeyAuthenticatorH\x03R\apasskey\x88\x01\x01B\t\n" +
	"\a_schemeB\f\n" +
	"\n" +
	"_signatureB\n" +
	"\n" +
	"\b_zkloginB\n" +
	"\n" +
	"\b_passkey\"\xfe\x02\n" +
	"\x14ZkLoginAuthenticator\x126\n" +
	"\x06inputs\x18\x01 \x01(\v2\x19.sui.rpc.v2.ZkLoginInputsH\x00R\x06inputs\x88\x01\x01\x12 \n" +
	"\tmax_epoch\x18\x02 \x01(\x04H\x01R\bmaxEpoch\x88\x01\x01\x12>\n" +
	"\tsignature\x18\x03 \x01(\v2\x1b.sui.rpc.v2.SimpleSignatureH\x02R\tsignature\x88\x01\x01\x12U\n" +
	"\x11public_identifier\x18\x04 \x01(\v2#.sui.rpc.v2.ZkLoginPublicIdentifierH\x03R\x10publicIdentifier\x88\x01\x01\x12-\n" +
	"\x06jwk_id\x18\x05 \x01(\v2\x11.sui.rpc.v2.JwkIdH\x04R\x05jwkId\x88\x01\x01B\t\n" +
	"\a_inputsB\f\n" +
	"\n" +
	"_max_epochB\f\n" +
	"\n" +
	"_signatureB\x14\n" +
	"\x12_public_identifierB\t\n" +
	"\a_jwk_id\"\xbb\x02\n" +
	"\rZkLoginInputs\x12@\n" +
	"\fproof_points\x18\x01 \x01(\v2\x18.sui.rpc.v2.ZkLoginProofH\x00R\vproofPoints\x88\x01\x01\x12K\n" +
	"\x12iss_base64_details\x18\x02 \x01(\v2\x18.sui.rpc.v2.ZkLoginClaimH\x01R\x10issBase64Details\x88\x01\x01\x12(\n" +
	"\rheader_base64\x18\x03 \x01(\tH\x02R\fheaderBase64\x88\x01\x01\x12&\n" +
	"\faddress_seed\x18\x04 \x01(\tH\x03R\vaddressSeed\x88\x01\x01B\x0f\n" +
	"\r_proof_pointsB\x15\n" +
	"\x13_iss_base64_detailsB\x10\n" +
	"\x0e_header_base64B\x0f\n" +
	"\r_address_seed\"\x9b\x01\n" +
	"\fZkLoginProof\x12'\n" +
	"\x01a\x18\x01 \x01(\v2\x14.sui.rpc.v2.CircomG1H\x00R\x01a\x88\x01\x01\x12'\n" +
	"\x01b\x18\x02 \x01(\v2\x14.sui.rpc.v2.CircomG2H\x01R\x01b\x88\x01\x01\x12'\n" +
	"\x01c\x18\x03 \x01(\v2\x14.sui.rpc.v2.CircomG1H\x02R\x01c\x88\x01\x01B\x04\n" +
	"\x02_aB\x04\n" +
	"\x02_bB\x04\n" +
	"\x02_c\"h\n" +
	"\fZkLoginClaim\x12\x19\n" +
	"\x05value\x18\x01 \x01(\tH\x00R\x05value\x88\x01\x01\x12#\n" +
	"\vindex_mod_4\x18\x02 \x01(\rH\x01R\tindexMod4\x88\x01\x01B\b\n" +
	"\x06_valueB\x0e\n" +
	"\f_index_mod_4\"^\n" +
	"\bCircomG1\x12\x13\n" +
	"\x02e0\x18\x01 \x01(\tH\x00R\x02e0\x88\x01\x01\x12\x13\n" +
	"\x02e1\x18\x02 \x01(\tH\x01R\x02e1\x88\x01\x01\x12\x13\n" +
	"\x02e2\x18\x03 \x01(\tH\x02R\x02e2\x88\x01\x01B\x05\n" +
	"\x03_e0B\x05\n" +
	"\x03_e1B\x05\n" +
	"\x03_e2\"\xc4\x01\n" +
	"\bCircomG2\x12\x15\n" +
	"\x03e00\x18\x01 \x01(\tH\x00R\x03e00\x88\x01\x01\x12\x15\n" +
	"\x03e01\x18\x02 \x01(\tH\x01R\x03e01\x88\x01\x01\x12\x15\n" +
	"\x03e10\x18\x03 \x01(\tH\x02R\x03e10\x88\x01\x01\x12\x15\n" +
	"\x03e11\x18\x04 \x01(\tH\x03R\x03e11\x88\x01\x01\x12\x15\n" +
	"\x03e20\x18\x05 \x01(\tH\x04R\x03e20\x88\x01\x01\x12\x15\n" +
	"\x03e21\x18\x06 \x01(\tH\x05R\x03e21\x88\x01\x01B\x06\n" +
	"\x04_e00B\x06\n" +
	"\x04_e01B\x06\n" +
	"\x04_e10B\x06\n" +
	"\x04_e11B\x06\n" +
	"\x04_e20B\x06\n" +
	"\x04_e21\"\xf3\x01\n" +
	"\x14PasskeyAuthenticator\x122\n" +
	"\x12authenticator_data\x18\x01 \x01(\fH\x00R\x11authenticatorData\x88\x01\x01\x12-\n" +
	"\x10client_data_json\x18\x02 \x01(\tH\x01R\x0eclientDataJson\x88\x01\x01\x12>\n" +
	"\tsignature\x18\x03 \x01(\v2\x1b.sui.rpc.v2.SimpleSignatureH\x02R\tsignature\x88\x01\x01B\x15\n" +
	"\x13_authenticator_dataB\x13\n" +
	"\x11_client_data_jsonB\f\n" +
	"\n" +
	"_signature\"y\n" +
	"\x12ValidatorCommittee\x12\x19\n" +
	"\x05epoch\x18\x01 \x01(\x04H\x00R\x05epoch\x88\x01\x01\x12>\n" +
	"\amembers\x18\x02 \x03(\v2$.sui.rpc.v2.ValidatorCommitteeMemberR\amembersB\b\n" +
	"\x06_epoch\"u\n" +
	"\x18ValidatorCommitteeMember\x12\"\n" +
	"\n" +
	"public_key\x18\x01 \x01(\fH\x00R\tpublicKey\x88\x01\x01\x12\x1b\n" +
	"\x06weight\x18\x02 \x01(\x04H\x01R\x06weight\x88\x01\x01B\r\n" +
	"\v_public_keyB\t\n" +
	"\a_weight\"\x9c\x01\n" +
	"\x1cValidatorAggregatedSignature\x12\x19\n" +
	"\x05epoch\x18\x01 \x01(\x04H\x00R\x05epoch\x88\x01\x01\x12!\n" +
	"\tsignature\x18\x02 \x01(\fH\x01R\tsignature\x88\x01\x01\x12\x1b\n" +
	"\x06bitmap\x18\x03 \x01(\fH\x02R\x06bitmap\x88\x01\x01B\b\n" +
	"\x06_epochB\f\n" +
	"\n" +
	"_signatureB\t\n" +
	"\a_bitmapb\x06proto3"

var (
	file_sui_rpc_v2_signature_proto_rawDescOnce sync.Once
	file_sui_rpc_v2_signature_proto_rawDescData []byte
)

func file_sui_rpc_v2_signature_proto_rawDescGZIP() []byte {
	file_sui_rpc_v2_signature_proto_rawDescOnce.Do(func() {
		file_sui_rpc_v2_signature_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_sui_rpc_v2_signature_proto_rawDesc), len(file_sui_rpc_v2_signature_proto_rawDesc)))
	})
	return file_sui_rpc_v2_signature_proto_rawDescData
}

var file_sui_rpc_v2_signature_proto_msgTypes = make([]protoimpl.MessageInfo, 18)
var file_sui_rpc_v2_signature_proto_goTypes = []any{
	(*UserSignature)(nil),                // 0: sui.rpc.v2.UserSignature
	(*SimpleSignature)(nil),              // 1: sui.rpc.v2.SimpleSignature
	(*ZkLoginPublicIdentifier)(nil),      // 2: sui.rpc.v2.ZkLoginPublicIdentifier
	(*MultisigMemberPublicKey)(nil),      // 3: sui.rpc.v2.MultisigMemberPublicKey
	(*MultisigMember)(nil),               // 4: sui.rpc.v2.MultisigMember
	(*MultisigCommittee)(nil),            // 5: sui.rpc.v2.MultisigCommittee
	(*MultisigAggregatedSignature)(nil),  // 6: sui.rpc.v2.MultisigAggregatedSignature
	(*MultisigMemberSignature)(nil),      // 7: sui.rpc.v2.MultisigMemberSignature
	(*ZkLoginAuthenticator)(nil),         // 8: sui.rpc.v2.ZkLoginAuthenticator
	(*ZkLoginInputs)(nil),                // 9: sui.rpc.v2.ZkLoginInputs
	(*ZkLoginProof)(nil),                 // 10: sui.rpc.v2.ZkLoginProof
	(*ZkLoginClaim)(nil),                 // 11: sui.rpc.v2.ZkLoginClaim
	(*CircomG1)(nil),                     // 12: sui.rpc.v2.CircomG1
	(*CircomG2)(nil),                     // 13: sui.rpc.v2.CircomG2
	(*PasskeyAuthenticator)(nil),         // 14: sui.rpc.v2.PasskeyAuthenticator
	(*ValidatorCommittee)(nil),           // 15: sui.rpc.v2.ValidatorCommittee
	(*ValidatorCommitteeMember)(nil),     // 16: sui.rpc.v2.ValidatorCommitteeMember
	(*ValidatorAggregatedSignature)(nil), // 17: sui.rpc.v2.ValidatorAggregatedSignature
	(*Bcs)(nil),                          // 18: sui.rpc.v2.Bcs
	(SignatureScheme)(0),                 // 19: sui.rpc.v2.SignatureScheme
	(*JwkId)(nil),                        // 20: sui.rpc.v2.JwkId
}
var file_sui_rpc_v2_signature_proto_depIdxs = []int32{
	18, // 0: sui.rpc.v2.UserSignature.bcs:type_name -> sui.rpc.v2.Bcs
	19, // 1: sui.rpc.v2.UserSignature.scheme:type_name -> sui.rpc.v2.SignatureScheme
	1,  // 2: sui.rpc.v2.UserSignature.simple:type_name -> sui.rpc.v2.SimpleSignature
	6,  // 3: sui.rpc.v2.UserSignature.multisig:type_name -> sui.rpc.v2.MultisigAggregatedSignature
	8,  // 4: sui.rpc.v2.UserSignature.zklogin:type_name -> sui.rpc.v2.ZkLoginAuthenticator
	14, // 5: sui.rpc.v2.UserSignature.passkey:type_name -> sui.rpc.v2.PasskeyAuthenticator
	19, // 6: sui.rpc.v2.SimpleSignature.scheme:type_name -> sui.rpc.v2.SignatureScheme
	19, // 7: sui.rpc.v2.MultisigMemberPublicKey.scheme:type_name -> sui.rpc.v2.SignatureScheme
	2,  // 8: sui.rpc.v2.MultisigMemberPublicKey.zklogin:type_name -> sui.rpc.v2.ZkLoginPublicIdentifier
	3,  // 9: sui.rpc.v2.MultisigMember.public_key:type_name -> sui.rpc.v2.MultisigMemberPublicKey
	4,  // 10: sui.rpc.v2.MultisigCommittee.members:type_name -> sui.rpc.v2.MultisigMember
	7,  // 11: sui.rpc.v2.MultisigAggregatedSignature.signatures:type_name -> sui.rpc.v2.MultisigMemberSignature
	5,  // 12: sui.rpc.v2.MultisigAggregatedSignature.committee:type_name -> sui.rpc.v2.MultisigCommittee
	19, // 13: sui.rpc.v2.MultisigMemberSignature.scheme:type_name -> sui.rpc.v2.SignatureScheme
	8,  // 14: sui.rpc.v2.MultisigMemberSignature.zklogin:type_name -> sui.rpc.v2.ZkLoginAuthenticator
	14, // 15: sui.rpc.v2.MultisigMemberSignature.passkey:type_name -> sui.rpc.v2.PasskeyAuthenticator
	9,  // 16: sui.rpc.v2.ZkLoginAuthenticator.inputs:type_name -> sui.rpc.v2.ZkLoginInputs
	1,  // 17: sui.rpc.v2.ZkLoginAuthenticator.signature:type_name -> sui.rpc.v2.SimpleSignature
	2,  // 18: sui.rpc.v2.ZkLoginAuthenticator.public_identifier:type_name -> sui.rpc.v2.ZkLoginPublicIdentifier
	20, // 19: sui.rpc.v2.ZkLoginAuthenticator.jwk_id:type_name -> sui.rpc.v2.JwkId
	10, // 20: sui.rpc.v2.ZkLoginInputs.proof_points:type_name -> sui.rpc.v2.ZkLoginProof
	11, // 21: sui.rpc.v2.ZkLoginInputs.iss_base64_details:type_name -> sui.rpc.v2.ZkLoginClaim
	12, // 22: sui.rpc.v2.ZkLoginProof.a:type_name -> sui.rpc.v2.CircomG1
	13, // 23: sui.rpc.v2.ZkLoginProof.b:type_name -> sui.rpc.v2.CircomG2
	12, // 24: sui.rpc.v2.ZkLoginProof.c:type_name -> sui.rpc.v2.CircomG1
	1,  // 25: sui.rpc.v2.PasskeyAuthenticator.signature:type_name -> sui.rpc.v2.SimpleSignature
	16, // 26: sui.rpc.v2.ValidatorCommittee.members:type_name -> sui.rpc.v2.ValidatorCommitteeMember
	27, // [27:27] is the sub-list for method output_type
	27, // [27:27] is the sub-list for method input_type
	27, // [27:27] is the sub-list for extension type_name
	27, // [27:27] is the sub-list for extension extendee
	0,  // [0:27] is the sub-list for field type_name
}

func init() { file_sui_rpc_v2_signature_proto_init() }
func file_sui_rpc_v2_signature_proto_init() {
	if File_sui_rpc_v2_signature_proto != nil {
		return
	}
	file_sui_rpc_v2_bcs_proto_init()
	file_sui_rpc_v2_jwk_proto_init()
	file_sui_rpc_v2_signature_scheme_proto_init()
	file_sui_rpc_v2_signature_proto_msgTypes[0].OneofWrappers = []any{
		(*UserSignature_Simple)(nil),
		(*UserSignature_Multisig)(nil),
		(*UserSignature_Zklogin)(nil),
		(*UserSignature_Passkey)(nil),
	}
	file_sui_rpc_v2_signature_proto_msgTypes[1].OneofWrappers = []any{}
	file_sui_rpc_v2_signature_proto_msgTypes[2].OneofWrappers = []any{}
	file_sui_rpc_v2_signature_proto_msgTypes[3].OneofWrappers = []any{}
	file_sui_rpc_v2_signature_proto_msgTypes[4].OneofWrappers = []any{}
	file_sui_rpc_v2_signature_proto_msgTypes[5].OneofWrappers = []any{}
	file_sui_rpc_v2_signature_proto_msgTypes[6].OneofWrappers = []any{}
	file_sui_rpc_v2_signature_proto_msgTypes[7].OneofWrappers = []any{}
	file_sui_rpc_v2_signature_proto_msgTypes[8].OneofWrappers = []any{}
	file_sui_rpc_v2_signature_proto_msgTypes[9].OneofWrappers = []any{}
	file_sui_rpc_v2_signature_proto_msgTypes[10].OneofWrappers = []any{}
	file_sui_rpc_v2_signature_proto_msgTypes[11].OneofWrappers = []any{}
	file_sui_rpc_v2_signature_proto_msgTypes[12].OneofWrappers = []any{}
	file_sui_rpc_v2_signature_proto_msgTypes[13].OneofWrappers = []any{}
	file_sui_rpc_v2_signature_proto_msgTypes[14].OneofWrappers = []any{}
	file_sui_rpc_v2_signature_proto_msgTypes[15].OneofWrappers = []any{}
	file_sui_rpc_v2_signature_proto_msgTypes[16].OneofWrappers = []any{}
	file_sui_rpc_v2_signature_proto_msgTypes[17].OneofWrappers = []any{}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_sui_rpc_v2_signature_proto_rawDesc), len(file_sui_rpc_v2_signature_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   18,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_sui_rpc_v2_signature_proto_goTypes,
		DependencyIndexes: file_sui_rpc_v2_signature_proto_depIdxs,
		MessageInfos:      file_sui_rpc_v2_signature_proto_msgTypes,
	}.Build()
	File_sui_rpc_v2_signature_proto = out.File
	file_sui_rpc_v2_signature_proto_goTypes = nil
	file_sui_rpc_v2_signature_proto_depIdxs = nil
}
